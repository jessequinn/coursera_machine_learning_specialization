1
00:00:00,383 --> 00:00:04,253
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community

2
00:00:04,253 --> 00:00:06,930
好了 我们已讨论了如何表示文档

3
00:00:06,930 --> 00:00:10,340
也讨论了如何衡量文档间的相似度

4
00:00:10,340 --> 00:00:14,170
现在开始我们真正关心的任务 检索文档

5
00:00:15,280 --> 00:00:18,870
某人正在阅读一篇文章 我们假设他很喜欢这篇文章

6
00:00:18,870 --> 00:00:21,920
我们想给他推荐阅读其他文章

7
00:00:21,920 --> 00:00:26,668
对此 特别地 最热门的一种方法叫做

8
00:00:26,668 --> 00:00:29,480
最近邻域搜索 我们有查询文档

9
00:00:29,480 --> 00:00:31,460
也就是正在读的这篇文章

10
00:00:31,460 --> 00:00:32,650
以及语料库

11
00:00:32,650 --> 00:00:35,930
也就是我们搜索其中来推荐新文章的

12
00:00:37,040 --> 00:00:39,070
所有文章的总和

13
00:00:39,070 --> 00:00:40,420
为了实现最近邻域搜索

14
00:00:40,420 --> 00:00:44,800
我们需要定义一个距离

15
00:00:44,800 --> 00:00:48,080
此量用来衡量我们之前提过的

16
00:00:48,080 --> 00:00:49,490
相似度

17
00:00:49,490 --> 00:00:54,670
这个算法的输出是一个相关文章的集合

18
00:00:57,020 --> 00:01:01,990
最近邻域搜索的一个特例叫做最近邻搜索

19
00:01:01,990 --> 00:01:04,790
当搜索查询文档时 返回的

20
00:01:04,790 --> 00:01:10,940
仅是搜索库中与查询文档最相关的一篇文章

21
00:01:10,940 --> 00:01:12,130
这个算法很简单直接

22
00:01:12,130 --> 00:01:15,619
我们只需搜索语料库中的每篇文档

23
00:01:15,619 --> 00:01:20,573
就是显示成绿色的这些 然后使用

24
00:01:20,573 --> 00:01:24,900
之前提到的方法计算查询文档与语料库中的

25
00:01:24,900 --> 00:01:27,640
文档间的相似度

26
00:01:27,640 --> 00:01:28,306
然后呢

27
00:01:28,306 --> 00:01:33,271
如果当前文档的相似度高于目前为止得到的所有相似度

28
00:01:33,271 --> 00:01:38,330
我们将保留当前文档作为目前最优结果

29
00:01:39,760 --> 00:01:45,020
在遍历过语料库中所有文档后

30
00:01:45,020 --> 00:01:48,360
我们则会将保留下来的最优选择

31
00:01:48,360 --> 00:01:51,010
推荐给读者

32
00:01:53,140 --> 00:01:56,710
这种算法的一个简单变体叫做k-近邻搜索

33
00:01:56,710 --> 00:02:01,220
与其输出查找到的最相关的一篇文章

34
00:02:01,220 --> 00:02:06,360
这个算法将返回最相关的k个不同的

35
00:02:06,360 --> 00:02:09,580
文章的集合给读者

36
00:02:09,580 --> 00:02:12,140
实现此目的的算法

37
00:02:12,140 --> 00:02:17,300
基本与前面相同 除了我们不仅要保留当前最相关的文章

38
00:02:17,300 --> 00:02:22,340
还需建立一优先队列来存放目前找到的k个最相关的文档
翻译: Emilily |审阅:
Coursera Global Translator Community