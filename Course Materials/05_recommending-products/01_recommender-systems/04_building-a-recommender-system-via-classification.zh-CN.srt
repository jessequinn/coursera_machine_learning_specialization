1
00:00:00,168 --> 00:00:04,284
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community

2
00:00:04,284 --> 00:00:07,978
前面我们已经讲了推荐系统的很多实际应用场景

3
00:00:07,978 --> 00:00:11,240
现在我们学习怎样搭建一个推荐系统

4
00:00:12,700 --> 00:00:15,130
其实推荐的方法和类型多如牛毛

5
00:00:15,130 --> 00:00:19,790
接下来我们来讲一部分

6
00:00:19,790 --> 00:00:23,850
可能最基本的方法是

7
00:00:23,850 --> 00:00:26,690
依据每个商品的流行度来推荐商品

8
00:00:26,690 --> 00:00:32,630
事实上这种方法在新网站中非常流行

9
00:00:32,630 --> 00:00:37,340
例如《纽约时报》网站边上有这样的流行度排名

10
00:00:37,340 --> 00:00:42,320
其中显示了不同分类下最流行的一些文章

11
00:00:42,320 --> 00:00:44,280
比如转发次数最多的一些文章

12
00:00:46,180 --> 00:00:49,910
所以当我们考虑给他人推荐文章时

13
00:00:49,910 --> 00:00:53,680
我们只要依据文章在纽约时报的

14
00:00:53,680 --> 00:00:55,725
总分享次数排序

15
00:00:55,725 --> 00:00:59,160
这样的效果很不错

16
00:00:59,160 --> 00:01:02,410
借助这种方法我经常能发现一些

17
00:01:02,410 --> 00:01:03,680
我很感兴趣的文章

18
00:01:03,680 --> 00:01:08,660
但是这种方法最大的缺点是缺乏个性化

19
00:01:08,660 --> 00:01:11,200
所有推荐的文章仅仅依赖于纽约时报上所有读者的阅读情况

20
00:01:11,200 --> 00:01:15,700
这样的推荐结果太泛了

21
00:01:15,700 --> 00:01:19,410
我想要的是一种能依据一些我个人的信息和兴趣的

22
00:01:19,410 --> 00:01:22,970
新文章推荐方法

23
00:01:25,500 --> 00:01:28,550
为了实现一定的个性化，我们需要使用一种分类模型

24
00:01:28,550 --> 00:01:33,210
它依据商品和用户的一些特征来

25
00:01:33,210 --> 00:01:35,600
做出推荐

26
00:01:35,600 --> 00:01:39,500
这种分类模型跟

27
00:01:39,500 --> 00:01:43,630
之前Carlos老师讲的情感分析的分类模型很像

28
00:01:43,630 --> 00:01:47,900
但是现在我们用

29
00:01:47,900 --> 00:01:52,560
这种方法来对某个用户是否喜欢某件商品进行分类

30
00:01:54,210 --> 00:01:57,984
好的 此处的分类方法的输入特征有

31
00:01:57,984 --> 00:02:01,086
这个用户的特征集 他购物记录的特征集

32
00:02:01,086 --> 00:02:05,307
这件正在考虑是否做推荐的商品的特征集

33
00:02:05,307 --> 00:02:08,931
可能还有很多其他的一些特征集

34
00:02:08,931 --> 00:02:12,730
我们将这些特征输入分类模型后

35
00:02:12,730 --> 00:02:16,353
如果它分类结果是yes 我相信这个用户会喜欢这件商品

36
00:02:16,353 --> 00:02:20,315
而如果它分类结果是no 那我认为这位用户不会喜欢这件商品

37
00:02:20,315 --> 00:02:24,560
这种分类方法有很多优点

38
00:02:24,560 --> 00:02:26,700
首先它是很个性化的

39
00:02:26,700 --> 00:02:31,550
因为我们使用了用户个人信息和他的购物记录作为特征

40
00:02:31,550 --> 00:02:34,490
第二个优点是这种分类方法能考虑到具体情景

41
00:02:34,490 --> 00:02:35,230
比方说

42
00:02:35,230 --> 00:02:39,700
我们可以将用户正在购物的具体时间作为特征

43
00:02:39,700 --> 00:02:42,960
要知道 我很可能会在白天买课本

44
00:02:42,960 --> 00:02:47,880
在晚上买家居商品

45
00:02:47,880 --> 00:02:51,580
第三个优点是它在用户购物记录很少的情况下

46
00:02:51,580 --> 00:02:53,650
也能运作良好

47
00:02:53,650 --> 00:02:56,800
比如说

48
00:02:56,800 --> 00:02:59,120
我在亚马逊上买过的商品不多

49
00:02:59,120 --> 00:03:03,160
很多推荐方法就不清楚我到底对哪些商品感兴趣

50
00:03:03,160 --> 00:03:08,260
但是如果有一些我的个人信息
即使是只知道我的年龄

51
00:03:08,260 --> 00:03:11,670
也能很好地预测哪些商品是我喜欢的

52
00:03:14,150 --> 00:03:17,430
当然这种分类方法也有一些不足

53
00:03:17,430 --> 00:03:20,750
最大的不足就是它所需的那些商品的特征集

54
00:03:20,750 --> 00:03:24,240
可能非常的多

55
00:03:24,240 --> 00:03:27,800
并且很有可能不全

56
00:03:27,800 --> 00:03:29,930
例如 你可能不知道我的年龄

57
00:03:29,930 --> 00:03:32,070
不知道我的性别

58
00:03:32,070 --> 00:03:34,120
缺失的信息可能还有很多

59
00:03:34,120 --> 00:03:38,680
比如商品信息的缺失或者写的很烂的产品说明书

60
00:03:38,680 --> 00:03:43,300
尤其在亚马逊上有

61
00:03:43,300 --> 00:03:45,250
很多人在买着各种各样的商品

62
00:03:45,250 --> 00:03:48,020
商品信息的质量可能很差

63
00:03:50,520 --> 00:03:54,350
事实上我们经常看到的方法是协同过滤

64
00:03:54,350 --> 00:03:56,620
我们将在下节讲到它比

65
00:03:56,620 --> 00:03:59,660
我们这种分类方法要好很多
翻译：xiaoliable | 审阅：Tod
Cousera Global Tranlator Community