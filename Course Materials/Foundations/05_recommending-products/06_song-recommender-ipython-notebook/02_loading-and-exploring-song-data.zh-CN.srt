1
00:00:00,000 --> 00:00:04,337
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community

2
00:00:04,337 --> 00:00:09,035
在这个模块中，艾米丽为我们展示了如何搭建一个产品推荐系统以及

3
00:00:09,035 --> 00:00:12,810
跟推荐系统相关的算法

4
00:00:12,810 --> 00:00:15,780
现在 让我们来建立一个Notebook 用来推荐

5
00:00:15,780 --> 00:00:16,770
我们可能想要听的歌曲

6
00:00:16,770 --> 00:00:19,410
这将会非常酷

7
00:00:20,950 --> 00:00:26,960
好的 就是在这里了 我们可以在这里重命名我们的Notebook

8
00:00:26,960 --> 00:00:31,920
这个叫歌曲推荐系统

9
00:00:34,490 --> 00:00:38,910
像之前一样 我将会隐藏页眉和

10
00:00:38,910 --> 00:00:41,870
工具栏 这样我们会有更多的空间

11
00:00:41,870 --> 00:00:47,310
照例我们从导入graphlab开始

12
00:00:47,310 --> 00:00:48,390
好的 从这开始了

13
00:00:50,250 --> 00:00:55,380
首先我们要做的是加载音乐数据

14
00:00:57,050 --> 00:01:03,370
加载音乐数据

15
00:01:04,390 --> 00:01:07,378
这是个很棒的数据库  叫做百万歌库

16
00:01:07,378 --> 00:01:10,209
然后我们创建一个叫song_data的变量

17
00:01:10,209 --> 00:01:11,750
它是用来存储的

18
00:01:11,750 --> 00:01:16,445
然后我们用graphlab.SFrame来

19
00:01:16,445 --> 00:01:21,737
读入 这是载入的一些数据

20
00:01:21,737 --> 00:01:24,664
这里， 我们读取了这些数据然后

21
00:01:24,664 --> 00:01:28,673
就可以开始一些数据检索了

22
00:01:28,673 --> 00:01:33,723
让我们检索一下

23
00:01:33,723 --> 00:01:38,970
其中一帧数据 一帧音乐数据

24
00:01:38,970 --> 00:01:43,400
那么首先我们要做的 像之前一样，

25
00:01:43,400 --> 00:01:46,490
是提取song_data来看看这个表格中的前几行

26
00:01:47,930 --> 00:01:51,290
这就是音乐数据的内容

27
00:01:51,290 --> 00:01:54,590
一个用来标记用户身份的user变量

28
00:01:55,840 --> 00:01:58,090
听一首歌的次数是一次还是两次

29
00:01:58,090 --> 00:02:02,589
这个是歌名 这个是歌手名称 还有

30
00:02:02,589 --> 00:02:06,730
这个是歌曲本身

31
00:02:06,730 --> 00:02:10,520
这个标题是专辑名称

32
00:02:10,520 --> 00:02:16,250
因此 就像我们看到的这样 我们只有

33
00:02:16,250 --> 00:02:21,606
一个显示着每个人听不同歌曲的频率的表格

34
00:02:21,606 --> 00:02:24,210
我们要用这个来建立一个推荐系统

35
00:02:24,210 --> 00:02:26,670
用来找出其他你可能有兴趣的歌曲

36
00:02:26,670 --> 00:02:30,340
我们会尝试一些不同类型的推荐系统

37
00:02:30,340 --> 00:02:33,760
就像艾米丽在这个模块中跟我们分享过的那些一样

38
00:02:34,850 --> 00:02:41,230
照例 我喜欢展示一下笔记本自身的直方图

39
00:02:41,230 --> 00:02:47,467
所以我要调用graphlab.canvas.set_target和

40
00:02:47,467 --> 00:02:50,243
在这命名ipynb

41
00:02:50,243 --> 00:02:54,540
这之后我再回到我的song_data变量

42
00:02:54,540 --> 00:02:58,344
我将会针对一个特定的列 比如说歌曲列 然后

43
00:02:58,344 --> 00:03:03,320
对它调用type.show函数 这会显示

44
00:03:03,320 --> 00:03:08,300
基于不同歌曲播放次数的直方图

45
00:03:08,300 --> 00:03:09,535
结果在这里

46
00:03:09,535 --> 00:03:14,062
这里是不同歌曲的标题 而

47
00:03:14,062 --> 00:03:20,280
你可以看到这里这首歌被播放了5970次

48
00:03:20,280 --> 00:03:26,134
这首比约克的歌被播放了5281次

49
00:03:26,134 --> 00:03:31,270
这里这首是一首巴西歌曲

50
00:03:31,270 --> 00:03:35,471
Catola的TVC 3185次

51
00:03:35,471 --> 00:03:40,274
所以有些人非常喜欢听他们的歌并且反复听很多次

52
00:03:40,274 --> 00:03:44,868
这就是我们想要的数据

53
00:03:44,868 --> 00:03:51,160
如果你快速查看一下这个音乐数据 你可以看看它的长度

54
00:03:51,160 --> 00:03:59,700
可以看到我们这里有110万首歌

55
00:03:59,700 --> 00:04:04,600
也就是百万对歌曲和用户的条目 这里的条目对应的是歌曲的评分

56
00:04:04,600 --> 00:04:07,190
这就是这个数据库 一个挺大的数据库

57
00:04:07,190 --> 00:04:13,040
我们来一起处理这个大型数据库吧

58
00:04:14,430 --> 00:04:17,540
让我们再稍稍探索一下

59
00:04:17,540 --> 00:04:20,846
我们说过对每个用户

60
00:04:20,846 --> 00:04:24,840
有大概1百万个评分或者1百万次播放

61
00:04:24,840 --> 00:04:27,290
让我们看看总共有多少用户

62
00:04:27,290 --> 00:04:33,413
我假设有

63
00:04:33,413 --> 00:04:39,990
哎呀 计算用户数

64
00:04:41,400 --> 00:04:45,320
用这个操作 我将会展示另一个有用的小技巧

65
00:04:45,320 --> 00:04:47,210
你以后自己处理数据的时候可以用

66
00:04:47,210 --> 00:04:52,860
我在这创建一个新的用户向量

67
00:04:52,860 --> 00:04:58,170
这个向量会从我们现有的音乐数据中

68
00:04:58,170 --> 00:05:03,343
查看用户名user_id那一列

69
00:05:04,600 --> 00:05:10,670
然后对它调用unique命令

70
00:05:10,670 --> 00:05:15,410
而unique命令的作用是选择所有这些用户

71
00:05:15,410 --> 00:05:19,120
只输出其中不重复的用户名

72
00:05:19,120 --> 00:05:20,630
只有所有的独立用户

73
00:05:20,630 --> 00:05:24,664
因此 如果我问起用户列表的长度

74
00:05:24,664 --> 00:05:30,010
你应该能看到我们总共有66346个独立用户

75
00:05:30,010 --> 00:05:34,900
而在这个数据库中总共有1百万首不同的歌

76
00:05:34,900 --> 00:05:38,090
你想的是评分项 而不是听同一首歌的次数

77
00:05:38,090 --> 00:05:39,138
以及歌曲相关活动的数据行

78
00:05:39,138 --> 00:05:43,839
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community