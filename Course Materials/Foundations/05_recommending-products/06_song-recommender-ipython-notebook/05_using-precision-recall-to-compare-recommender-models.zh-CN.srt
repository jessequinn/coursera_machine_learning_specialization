1
00:00:00,078 --> 00:00:04,090
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community

2
00:00:04,090 --> 00:00:08,020
那么 我们现在已经见识过这些模型的应用实例了

3
00:00:08,020 --> 00:00:15,760
我们也进行了我们称为

4
00:00:15,760 --> 00:00:19,790
定性或者例证定性分析

5
00:00:19,790 --> 00:00:23,380
让我们来做些定量比较

6
00:00:23,380 --> 00:00:27,700
来对比个性化和流行度模型

7
00:00:27,700 --> 00:00:33,079
那么我们现在要

8
00:00:33,079 --> 00:00:38,704
做量化对比

9
00:00:38,704 --> 00:00:43,120
来比较不同的模型

10
00:00:43,120 --> 00:00:49,310
那我们在本课中

11
00:00:49,310 --> 00:00:54,230
比较推荐系统的时候 一个很好的度量方法是精度召回率

12
00:00:54,230 --> 00:01:00,402
所以我们可以绘出这两个模型的精度召回率曲线吗？

13
00:01:00,402 --> 00:01:06,020
我们在另一个笔记本中讨论过matplotlib

14
00:01:06,020 --> 00:01:10,724
这里我们将调用matplotlib

15
00:01:10,724 --> 00:01:15,559
我在行内加上了这个小小的命令inline

16
00:01:15,559 --> 00:01:20,265
这样能保证matplotlib能融入

17
00:01:20,265 --> 00:01:25,380
推荐系统  也就是融入Notebook

18
00:01:26,740 --> 00:01:34,170
matplotlib的功能是计算模型的性能

19
00:01:36,360 --> 00:01:42,240
这个是我定义的变量 以及

20
00:01:42,240 --> 00:01:47,265
在graphlab.create中的推荐系统资料库里的这个方法

21
00:01:47,265 --> 00:01:50,615
它是一套推荐系统的实用程序包

22
00:01:50,615 --> 00:01:53,855
其中有一个非常酷的包叫compare_models

23
00:01:53,855 --> 00:01:57,725
你可以试着比较不同的推荐器模型来理解他们是如何运作的

24
00:01:57,725 --> 00:02:01,956
我要比较不同的推荐系统

25
00:02:01,956 --> 00:02:04,668
用的是我们分离出来的测试数据

26
00:02:04,668 --> 00:02:10,329
而我要比较的模型有流行度模型和

27
00:02:10,329 --> 00:02:17,554
个性化模型 这里的列表里有两个要做比较的模型

28
00:02:17,554 --> 00:02:22,580
我可以比较更多 但是现在我只比较这两个

29
00:02:22,580 --> 00:02:28,190
然后我想说这里有一个小的参数叫做user_sample

30
00:02:28,190 --> 00:02:34,030
我要用它来采样一小部分的测试数据

31
00:02:34,030 --> 00:02:38,456
这里我们把user_sample设置为0.05  因为

32
00:02:38,456 --> 00:02:43,550
要搭建这个机器系统需要一点时间

33
00:02:43,550 --> 00:02:46,950
而我们想要尽快看到结果进行分析

34
00:02:46,950 --> 00:02:49,240
好了 这次挺快的

35
00:02:49,240 --> 00:02:55,380
它在进行对比 首先评估流行度模型的性能

36
00:02:55,380 --> 00:02:57,090
这是零号模型

37
00:02:57,090 --> 00:02:59,380
然后是第二个模型的性能

38
00:02:59,380 --> 00:03:02,320
一号模型 也就是个性化模型

39
00:03:02,320 --> 00:03:05,350
最后我们在这里得到一个精度召回率曲线

40
00:03:05,350 --> 00:03:10,040
我们在课程中最后讲到过

41
00:03:10,040 --> 00:03:13,910
这个曲线能比较两个模型的召回率和精确度

42
00:03:13,910 --> 00:03:20,000
绿色曲线代表个性化模型 蓝色曲线代表流行度模型

43
00:03:20,000 --> 00:03:24,680
这个曲线越靠近顶部就越好

44
00:03:24,680 --> 00:03:28,920
你可以看到引入个性化后 显著提高了

45
00:03:28,920 --> 00:03:32,080
我们推荐系统的性能

46
00:03:32,080 --> 00:03:33,870
所以 个性化是很有用的

47
00:03:33,870 --> 00:03:36,000
只是推荐流行的条目 没那么有用

48
00:03:37,010 --> 00:03:43,070
基于此 我们已经搭建了一个推荐系统

49
00:03:43,070 --> 00:03:47,979
我们分析了结果 发现它能给我这种U2和乐士浮生录的歌迷

50
00:03:47,979 --> 00:03:52,070
推荐不错的歌曲

51
00:03:52,070 --> 00:03:57,677
当然你也可以去尝试你喜欢的东西

52
00:03:57,677 --> 00:04:02,653
看看你能得到哪些其它的推荐歌曲

53
00:04:02,653 --> 00:04:06,709
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community