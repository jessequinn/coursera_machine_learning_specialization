1
00:00:00,000 --> 00:00:04,338
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community

2
00:00:04,338 --> 00:00:08,644
好的 为了处理流行商品问题

3
00:00:08,644 --> 00:00:13,340
我们需要将同现矩阵规格化(标准化 正规化)

4
00:00:13,340 --> 00:00:17,290
我们常使用的矩阵规格化方法是

5
00:00:17,290 --> 00:00:18,010
Jaccard相似度

6
00:00:19,048 --> 00:00:21,870
此处的同现矩阵规格化为问题

7
00:00:21,870 --> 00:00:25,270
非常像我们之前讲过的

8
00:00:25,270 --> 00:00:29,450
聚类和相似度部分

9
00:00:29,450 --> 00:00:34,940
我们在讲tf/idf（词频/逆向文件频率）时

10
00:00:34,940 --> 00:00:38,800
曾讲过词频很高的词的作用力会

11
00:00:38,800 --> 00:00:43,540
盖过我们可能关心的其他词

12
00:00:43,540 --> 00:00:47,090
所以我们才采用tf/idf方法来

13
00:00:47,090 --> 00:00:51,480
规格化代表文档的原词统计

14
00:00:51,480 --> 00:00:52,260
在这个案例中这种方法

15
00:00:52,260 --> 00:00:57,310
我们可以借鉴来处理流行商品问题

16
00:00:58,430 --> 00:01:01,110
这种方法用起来很直接

17
00:01:01,110 --> 00:01:06,290
我们只需要统计有多少人

18
00:01:06,290 --> 00:01:06,930
同时购买了i和j

19
00:01:08,220 --> 00:01:14,000
这是同时购买i和j的人数

20
00:01:14,000 --> 00:01:18,010
它的值能在之前的矩阵找到

21
00:01:18,010 --> 00:01:19,840
这是原来的次数

22
00:01:19,840 --> 00:01:22,410
我们将用

23
00:01:22,410 --> 00:01:25,349
同时购买i和j的人数除以买了i或j的人数

24
00:01:26,600 --> 00:01:33,461
这样就得到规格化之后的次数

25
00:01:33,461 --> 00:01:37,500
我们可以画一个简单的维恩图（Venn）来表示

26
00:01:40,370 --> 00:01:44,047
这个圈表示所有买了i的人

27
00:01:48,700 --> 00:01:53,879
这个圈表示所有买了j的人

28
00:01:55,672 --> 00:02:00,712
中间划线的区域表示同时买了i和j的人

29
00:02:04,150 --> 00:02:08,337
那么我们就将划线区域同时买i和j的人数

30
00:02:08,337 --> 00:02:12,213
作为分子

31
00:02:12,213 --> 00:02:16,200
除以整个区域

32
00:02:16,200 --> 00:02:21,212
我把颜色调得更明显一点

33
00:02:27,421 --> 00:02:36,110
沿着购买了i或j的用户区域边缘画

34
00:02:36,110 --> 00:02:37,671
这就是计算的分母

35
00:02:40,671 --> 00:02:45,519
好的 这样我们的共现矩阵就规格化了

36
00:02:45,519 --> 00:02:49,875
当然我们可以考虑余弦相似度

37
00:02:49,875 --> 00:02:53,690
我们将在随后的部分再
讲一些其他的计算方法

38
00:02:55,540 --> 00:02:57,980
这种方法也有一些局限

39
00:02:57,980 --> 00:03:01,570
其中一个问题就是它只考虑目前的状态

40
00:03:01,570 --> 00:03:04,490
在给我做推荐的时候

41
00:03:04,490 --> 00:03:07,260
它只考虑我刚买了玩具Sophie the giraffe

42
00:03:07,260 --> 00:03:10,220
却并没有考虑我整个历史购物商品

43
00:03:10,220 --> 00:03:11,830
对推荐的影响

44
00:03:13,800 --> 00:03:18,300
好的 我们可以调整我们的之前的方法使之

45
00:03:18,300 --> 00:03:19,880
将我的购物历史考虑进来

46
00:03:21,270 --> 00:03:25,390
一种简单的调整就是给每次我给商品打的分

47
00:03:25,390 --> 00:03:28,350
加上一个权重系数

48
00:03:28,350 --> 00:03:30,490
对我购物历史的所有商品都加上

49
00:03:30,490 --> 00:03:32,740
举例来说

50
00:03:32,740 --> 00:03:38,800
比如我曾在Amazon上买过尿布和牛奶

51
00:03:38,800 --> 00:03:42,860
现在对我进行推荐

52
00:03:42,860 --> 00:03:48,210
我将浏览所有推荐给我的商品

53
00:03:48,210 --> 00:03:51,910
并对它们进行打分

54
00:03:51,910 --> 00:03:55,580
假设我正需要

55
00:03:55,580 --> 00:03:57,970
婴儿纸巾

56
00:03:57,970 --> 00:03:59,250
在这种情况下

57
00:03:59,250 --> 00:04:03,820
我就会算出收到推荐婴儿纸巾的

58
00:04:03,820 --> 00:04:08,760
权重系数

59
00:04:08,760 --> 00:04:11,400
计算方法我们刚刚讲过

60
00:04:11,400 --> 00:04:14,270
找到尿布列值

61
00:04:14,270 --> 00:04:17,650
找出买尿布的人同时买婴儿湿巾的次数

62
00:04:17,650 --> 00:04:20,930
同样也要找出买牛奶的人同时买

63
00:04:20,930 --> 00:04:24,340
婴儿湿巾的次数
这两个数的平均数就表示

64
00:04:24,340 --> 00:04:29,040
对这两个结果做平均来看看多大可能

65
00:04:30,490 --> 00:04:34,170
我将会买婴儿湿巾的可能性

66
00:04:35,930 --> 00:04:39,360
当然我们也可以根据具体情况做一些调整

67
00:04:39,360 --> 00:04:44,250
而不是仅仅简单地计算平均数

68
00:04:44,250 --> 00:04:46,980
比如将更近的购买记录权重设大一点

69
00:04:48,250 --> 00:04:51,560
好的 最终只要将加权平均分排序

70
00:04:51,560 --> 00:04:55,670
并推荐分数最高的商品就可以了

71
00:04:55,670 --> 00:04:59,274
跟之前的购买过程很相似

72
00:04:59,274 --> 00:05:02,962
只不过现在在购买历史中加上了权重系数

73
00:05:05,004 --> 00:05:07,580
但是这种方法还是有一些缺陷

74
00:05:07,580 --> 00:05:12,890
比如没有显著地考虑其他因素
比方说购买发生的时间段

75
00:05:12,890 --> 00:05:17,760
没有考虑用户的特征

76
00:05:17,760 --> 00:05:20,845
比如年龄 性别等等

77
00:05:20,845 --> 00:05:25,160
它只是考虑了所有用户的同现矩阵

78
00:05:26,310 --> 00:05:29,030
同样地 它也没有考虑商品的特征

79
00:05:29,030 --> 00:05:34,200
它推荐时考虑的很多东西都跟

80
00:05:34,200 --> 00:05:38,550
商品的任何特征属性无关

81
00:05:39,850 --> 00:05:42,610
面临的另一个大问题是

82
00:05:42,610 --> 00:05:43,240
冷启动问题

83
00:05:43,240 --> 00:05:46,170
这是一个很多领域都会遇到的

84
00:05:46,170 --> 00:05:46,990
大问题

85
00:05:46,990 --> 00:05:49,130
接下来我们细讲一下

86
00:05:49,130 --> 00:05:53,610
此处当需要考虑一个新商品或者用户

87
00:05:53,610 --> 00:05:55,290
我们就会遇到冷启动问题

88
00:05:55,290 --> 00:05:57,650
这时我们怎么进行推荐呢

89
00:05:57,650 --> 00:06:01,830
我们没有这个商品的历史购买记录

90
00:06:01,830 --> 00:06:06,070
不知道它跟其他商品同时被购买的次数

91
00:06:06,070 --> 00:06:08,230
应为它从来没有出现过

92
00:06:08,230 --> 00:06:12,129
同样地我们也没有新用户的历史购买记录

93
00:06:12,129 --> 00:06:15,929
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community