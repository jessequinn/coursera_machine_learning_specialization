1
00:00:00,000 --> 00:00:04,220
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community

2
00:00:04,220 --> 00:00:08,272
到目前为止我们所讨论的共生方法中

3
00:00:08,272 --> 00:00:12,473
并没用从我作为一名用户不同的方面或者从

4
00:00:12,473 --> 00:00:17,240
产品所具备的特征 来驱动建议的生成

5
00:00:17,240 --> 00:00:21,040
反而我们是对购买量和用户购买历史进行

6
00:00:21,040 --> 00:00:22,910
简单的共生计算

7
00:00:22,910 --> 00:00:28,090
因此一个自然的问题就是 我们是否能够以某种方法利用

8
00:00:28,090 --> 00:00:32,050
关于我是谁以及产品是什么的信息 来驱动建议生成

9
00:00:32,050 --> 00:00:35,020
就像我们在分类方法中所讨论的

10
00:00:35,020 --> 00:00:38,830
我们有一些用户和产品特征的集合

11
00:00:38,830 --> 00:00:43,540
但这里 我们是想去从数据中学习这些特征

12
00:00:43,540 --> 00:00:46,260
这将有助于处理我们刚讨论的

13
00:00:46,260 --> 00:00:48,140
这些特征有可能不可获得的问题

14
00:00:49,470 --> 00:00:52,880
另外 我们还想考虑用户和物品间的相互作用

15
00:00:52,880 --> 00:00:58,630
就像我们在共生应用或者共生方法中做的那样

16
00:00:58,630 --> 00:01:02,510
接下来我们将在一个电影推荐任务的背景下去讨论这些

17
00:01:02,510 --> 00:01:05,400
因为讨论这个应用非常直观地体现了

18
00:01:05,400 --> 00:01:07,580
我们将要介绍的方法

19
00:01:07,580 --> 00:01:12,720
在这个应用中 我们所拥有的数据就是这个大表格

20
00:01:12,720 --> 00:01:17,830
表格中我们收集了大量的用户数据 包括他们看的一些电影

21
00:01:17,830 --> 00:01:20,090
以及他们对电影的评价 明白了吗？

22
00:01:20,090 --> 00:01:26,860
因此 我们的表格就像这样 比如绿色用户上线

23
00:01:26,860 --> 00:01:31,860
他看了3部不同的影片 并分别给了三星 五星以及两星的评价

24
00:01:31,860 --> 00:01:35,950
然后接下来是这位蓝色用户 他看了2部不同的影片

25
00:01:35,950 --> 00:01:38,300
而粉色用户 看了4不同的影片

26
00:01:39,310 --> 00:01:45,680
这样 我们就有了个由用户 电影 评价组成的巨大表格

27
00:01:48,760 --> 00:01:53,950
然而 其实每个用户只看了全部电影中的几部

28
00:01:53,950 --> 00:01:58,813
接下来 我们将把这个数据表格转换成一个巨大的

29
00:01:58,813 --> 00:01:59,607
用户对电影评价的矩阵。

30
00:01:59,607 --> 00:02:04,144
这个矩阵之所以巨大 通常因为它包含大量的用户

31
00:02:04,144 --> 00:02:05,730
和大量的电影

32
00:02:05,730 --> 00:02:08,798
但是同时 这个矩阵也是十分稀疏的

33
00:02:08,798 --> 00:02:14,210
虽然这里有许多许多的电影 甚至还有许多用户

34
00:02:14,210 --> 00:02:18,670
但是每个用户其实只看过一小部分的电影

35
00:02:18,670 --> 00:02:24,690
因此 如我上面所说 这是一个用户对于电影的矩阵

36
00:02:24,690 --> 00:02:29,720
那么 比如说 这一行就代表了用户u

37
00:02:29,720 --> 00:02:32,210
这一列则代表了电影v

38
00:02:33,590 --> 00:02:41,740
那么 这个黑色的方块代表了用户u对于电影v的评价

39
00:02:41,740 --> 00:02:46,809
因此 这是一个

40
00:02:46,809 --> 00:02:53,930
由用户u对电影v做出的评价

41
00:02:53,930 --> 00:02:56,990
所以这里有少量的黑色方块 但却有很多

42
00:02:56,990 --> 00:02:59,120
很多的白色方块

43
00:02:59,120 --> 00:03:06,140
因此一个白色方块代表了一个未知的问号

44
00:03:06,140 --> 00:03:08,660
它代表某一用户并没有看过某部电影 或者

45
00:03:08,660 --> 00:03:11,230
至少该用户没有提供对该电影的评价

46
00:03:14,130 --> 00:03:17,950
这里我想说明的是 所有的白色方块都代表

47
00:03:17,950 --> 00:03:19,170
未知的评价

48
00:03:19,170 --> 00:03:21,030
它们不是代表零分评价

49
00:03:21,030 --> 00:03:23,380
不是表示用户不喜欢这部电影

50
00:03:23,380 --> 00:03:26,720
它只是表示我们并不清楚用户是如何看待这部电影的

51
00:03:27,730 --> 00:03:35,650
这样 我们就称 rating(u,v)  是一个

52
00:03:35,650 --> 00:03:40,650
用户u给电影v的评价 这个评价对黑方块是已知的

53
00:03:40,650 --> 00:03:45,299
这些是有评分的情况 而白色方块是未知的

54
00:03:46,350 --> 00:03:51,160
现在我们的目标是填写所有这些问号 即这些白色的方块

55
00:03:52,160 --> 00:03:55,090
接下来我们所使用的方法会充分利用

56
00:03:55,090 --> 00:04:00,640
用户提供的所有评价 即与该用户相关的所有黑色方块

57
00:04:00,640 --> 00:04:03,590
让我快速换一下笔的颜色

58
00:04:03,590 --> 00:04:11,380
这样我们选取了由这个用户提供的所有评价 并用它们来

59
00:04:12,770 --> 00:04:17,930
预测该用户对这些问号的评价

60
00:04:17,930 --> 00:04:23,005
事实上 所有这些问号 我们将填入

61
00:04:23,005 --> 00:04:28,830
这个用户的历史信息 其他用户也是这样处理

62
00:04:30,150 --> 00:04:30,650
好

63
00:04:31,820 --> 00:04:37,090
这样我们使用这个用户 以及其他用户的历史评价信息

64
00:04:37,090 --> 00:04:40,110
来预测

65
00:04:40,110 --> 00:04:43,970
用户对于他们尚未看过的电影 喜爱程度是多少

66
00:04:43,970 --> 00:04:47,110
让我讲得更清楚一些

67
00:04:47,110 --> 00:04:53,470
这就是 我们将填写这个问号

68
00:04:54,560 --> 00:04:59,500
我想重申下 我们不是只利用这个用户的评价

69
00:04:59,500 --> 00:05:04,030
当我们进行推测的时候 我们会利用所有的评价信息

70
00:05:05,200 --> 00:05:09,808
我不想再在每个黑色格子上圈红方块 以免你觉得无聊

71
00:05:09,808 --> 00:05:13,142
但你得知道我们是利用所有的信息来填写

72
00:05:13,142 --> 00:05:14,472
这个真的很大的稀疏矩阵

73
00:05:14,472 --> 00:05:18,579
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community