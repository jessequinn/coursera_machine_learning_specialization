1
00:00:00,000 --> 00:00:03,035
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community

2
00:00:03,035 --> 00:00:06,560
很好，所以这是我们的数据

3
00:00:06,560 --> 00:00:11,320
那我们下一步要创建一个推荐系统

4
00:00:11,320 --> 00:00:14,030
那么我们开始吧

5
00:00:16,420 --> 00:00:23,180
让我们马上开始搭建一个歌曲推荐系统

6
00:00:25,580 --> 00:00:29,920
照例，我们一开始要划分训练数据和测试数据

7
00:00:29,920 --> 00:00:35,076
因此我们定义train_data时 数据已经被分成了训练数据和测试数据

8
00:00:35,076 --> 00:00:39,642
而划分的方法是将音乐数据

9
00:00:39,642 --> 00:00:46,921
随机地划分开来，其中训练数据占80%

10
00:00:46,921 --> 00:00:50,942
测试数据占20%

11
00:00:50,942 --> 00:00:53,882
还有 别忘了把这个量归零

12
00:00:53,882 --> 00:00:58,009
这样你在家自己计算的时候就会得到完全一样的结果了

13
00:00:59,490 --> 00:01:00,970
好了 我们完成了划分

14
00:01:00,970 --> 00:01:05,690
我们现在准备好要训练一些推荐器的模型了

15
00:01:05,690 --> 00:01:12,153
因此只需要按照艾米丽之前讲到的

16
00:01:12,153 --> 00:01:17,195
我们第一个训练的推荐器模型是

17
00:01:17,195 --> 00:01:22,900
一个简单的基于流行程度的推荐系统

18
00:01:24,210 --> 00:01:27,470
这是很多网站用到的 比如说 当他们说

19
00:01:27,470 --> 00:01:31,270
这是最多邮件转发的故事或者这是购买量最大的产品，

20
00:01:31,270 --> 00:01:35,200
或者这是今天推特上最流行最常用的标签

21
00:01:36,450 --> 00:01:39,234
这并不是一个特别好的模型 但是它非常常用

22
00:01:39,234 --> 00:01:44,810
好的 让我们来训练这个著名的基于流行度的模型吧

23
00:01:44,810 --> 00:01:46,850
我把它命名为popularity_model

24
00:01:46,850 --> 00:01:53,060
我现在只需要调用graphlab.popularity_recommender

25
00:01:53,060 --> 00:01:55,930
这是一个专有的推荐系统

26
00:01:55,930 --> 00:01:58,820
我尝试在它下面调用create 如果

27
00:01:58,820 --> 00:02:02,900
你还记得的话 create在这里是用来创建推荐系统的动词

28
00:02:04,370 --> 00:02:10,130
然后 我将把我的训练数据作为输入量

29
00:02:12,700 --> 00:02:17,720
这个模型会读入一些信息

30
00:02:17,720 --> 00:02:19,530
那么让我来一步步展示给你看

31
00:02:19,530 --> 00:02:25,180
你需要指出数据库中的那一列是用户名

32
00:02:25,180 --> 00:02:29,690
在我们这个例子中那一列就叫做user_id

33
00:02:29,690 --> 00:02:32,840
用户名

34
00:02:32,840 --> 00:02:37,795
接着我们需要指明条目名

35
00:02:40,358 --> 00:02:45,320
而条目名 或者我们例子中的产品名 也就是用户和产品

36
00:02:45,320 --> 00:02:48,000
但是我们的条目并不是严格意义上的产品

37
00:02:48,000 --> 00:02:49,584
这里我们的条目是歌曲

38
00:02:49,584 --> 00:02:55,880
因此条目名等于歌曲名 那我现在按回车 它会很快创建

39
00:02:55,880 --> 00:03:02,310
一个简单的基于流行度的推荐系统

40
00:03:02,310 --> 00:03:05,060
现在让我们来做预测

41
00:03:05,060 --> 00:03:12,168
那下一步我们用，

42
00:03:12,168 --> 00:03:18,135
让我把鼠标向下滚动一下

43
00:03:18,135 --> 00:03:22,762
我们用流行度模型来

44
00:03:22,762 --> 00:03:26,993
做一些预测

45
00:03:29,938 --> 00:03:34,852
比如说我们用这个流行度模型来

46
00:03:34,852 --> 00:03:39,550
对一个特定用户进行推荐

47
00:03:40,830 --> 00:03:45,928
那么我要推荐一些这个用户喜欢的歌曲

48
00:03:45,928 --> 00:03:50,160
因此 这个推荐器函数会提取一些用户

49
00:03:50,160 --> 00:03:52,040
而我们现在就给它提供其中一个用户

50
00:03:52,040 --> 00:03:54,310
如果你记得的话 我们有一个用户列表

51
00:03:54,310 --> 00:03:59,510
我就把那个用户列表的第一个人输入函数并运行

52
00:03:59,510 --> 00:04:02,040
那么你会给这个人推荐什么呢

53
00:04:02,040 --> 00:04:10,080
一首Harmonia的歌 一首比约克的 一首里昂王朝的，等等

54
00:04:11,550 --> 00:04:13,290
那么现在仔细看一下这个结果

55
00:04:13,290 --> 00:04:17,200
这里的约卡姆是推荐给零号用户的

56
00:04:17,200 --> 00:04:21,150
现在我们看看这个模型给一号用户推荐的是什么

57
00:04:21,150 --> 00:04:25,448
我们再用这个流行度模型

58
00:04:25,448 --> 00:04:32,590
我再调用一次这个推荐系统，给它一组用户

59
00:04:32,590 --> 00:04:36,200
这一次 我不用零号用户 而是用一号用户

60
00:04:36,200 --> 00:04:42,150
现在在我按回车之前 先停下来想一想

61
00:04:42,150 --> 00:04:44,140
我从这个流行度模型中会得到什么结果呢？

62
00:04:46,780 --> 00:04:49,770
嗯 每个人都会被推荐完全一样的东西。

63
00:04:49,770 --> 00:04:52,040
因为我们只是推荐了最流行的歌曲

64
00:04:52,040 --> 00:04:57,040
因此这个人也会被推荐Harmonia 比约克 德怀特约卡姆

65
00:04:57,040 --> 00:05:00,040
里昂王朝 基本上 这并不很有趣

66
00:05:00,040 --> 00:05:03,310
因为所有人都得到了相同的推荐

67
00:05:03,310 --> 00:05:04,613
这是这个模型的一个问题

68
00:05:04,613 --> 00:05:07,774
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community